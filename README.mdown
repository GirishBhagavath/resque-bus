## Resque Bus

This gem uses Redis and Resque to allow simple asynchronous communication between apps.

### Example

Application A can publish an event

    # config
    ResqueBus.redis = "192.168.1.1:6379"
    ResqueBus.app_key = "app_a"

    # business logic
    ResqueBus.publish("user_created", "id" => 42, "first_name" => "John", "last_name" => "Smith")

Application B is subscribed to events

    # config
    ResqueBus.redis = "192.168.1.1:6379"
    ResqueBus.app_key = "app_b"
    
    # initializer
    ResqueBus.dispatch do
      # processes event on app_b_default queue
      subscribe "user_created" do |attributes|
        NameCount.find_or_create_by_name(attributes["last_name"]).increment!
      end
      
      # processes event on app_b_critical queue
      critical "user_paid" do |attributes|
        CreditCard.charge!(attributes)
      end
      
      # you can leave the attributes off if you like
      subscribe "user_homepage_visit" do
        GoogleAnalytics.increment!("homepage")
      end
      
      # and regexes work as well. note that with the above configuration along with this regex,
      # the following as well as the corresponding block above would both be executed
      subscribe /^user_/ do |attributes|
        Metrics.record_user_action(attributes["bus_event_type"], attributes["id"])
      end
      
      # however, this would overwrite the relevant block above
      subscribe "user_homepage_visit" do
        Mixpanel.increment!("homepage")
      end
    end

The subscription block is run inside a Resque worker which needs to be started for each app.

    $ rake resquebus:work
    
The incoming queue also needs to be processed on a dedicated or all the app servers.

    $ rake resquebus:driver
    

### Compatibility

ResqueBus can live along side another instance of Resque that points at a different Redis server.
    
    # config
    Resque.redis = "192.168.1.0:6379"
    ResqueBus.redis = "192.168.1.1:6379"
    ResqueBus.app_key = "app_a"

If no Redis instance is given specifically, ResqueBus will use the Resque one.

    # config
    Resque.redis = "192.168.1.0:6379"
    ResqueBus.app_key = "app_a"

That will use the default (resque) namespace which can be helpful for using the tooling. Conflict with queue names are unlikely. You can change the namepsace if you like though.

    # config
    Resque.redis = "192.168.1.0:6379"
    ResqusBus.redis.namespace = :get_on_the_bus
    ResqueBus.app_key = "app_a"   


### TODO

* There are a few spots in the code with TODO notes
* Make this not freak out in development without Redis or when Redis is down
* We might not actually need to publish in tests
* Add some rspec helpers for the apps to use: should_ post an event_publish or something along those lines
* A synchronous version will be needed for several use cases. Make it so that an event can go in real-time to one subscriber and still be async to the rest.
    
Copyright (c) 2011 Brian Leonard, released under the MIT license
